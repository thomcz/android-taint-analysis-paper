\documentclass[runningheads]{llncs}

%---- Codierung----%
\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{url}
\usepackage{llncsdoc}
%----- Mathematischer Zeichenvorrat---%
%\usepackage{amsmath}
%\usepackage{amssymb}
%\usepackage{enumerate}
\usepackage{proof}
\usepackage{mathpartir}
% fuer die aktuelle Zeit 
\usepackage{scrtime}
\usepackage{listings}
\usepackage{subfigure}
\usepackage{hyperref}

%referenzieren von Abbildungen
\usepackage[figure]{hypcap}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}

% Syntax highlighting von Java Code
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=8mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\begin{document}

\mainmatter
\title{Taint Analyse für Android Apps}
\titlerunning{Taint Analyse für Android Apps}
\author{Thomas Czogalik}
\authorrunning{Desaster in der Software-Sicherheit (WiSe15/16)}
\institute{Betreuer: Simon Greiner}
\date{31.03.2016}
\maketitle

\section{Motivation}
Durch fehlerhafte oder absichtlich manipulierte Programme können Datenlecks enstehen und diese ausgenutzt werden. 
In Abbildung \ref{fig:sql_code} sehen wir ein Ausschnit aus einem Java Programm. Es wird zunächst eine Datenbank Verbindung hergestellt und im Anschluß soll ein SQL Statement ausgeführt werden. Wie wir in Zeile 6 sehen, hängt das Statement von einer Benutzereingabe aus Zeile 5 ab. Ein Angreifer könnte in diesem Fall durch folgende Eingabe: "foo; DROP TABLE users" die Datenbank users löschen. Er könnte aber auch mit einem SELECT Statement Daten aus der Datenbank holen. Solche Szenarien lassen sich durch Überprüfung vermeiden. So ein Fehler ist aber nicht immer so einfach zu erkenne und wird übersehen. Da Computersysteme heutzutage in nahezu allen Bereichen unseres Lebens intigriert sind, können solche Datenlecks fatale folgen haben. Besonders Smartphones verwalten und verarbeiten viele vertauliche und private Daten und komunizieren dabei meißt mit der Außenwelt. Im Februar 2015 befanden sich im Google Play Store ca. 1.4 Millionen Apps. Diese sind jedem zugänglich, der auf seinem mobilen Gerät das Betriebssystem Android installiert hat. Bei so einer großen Anzahl Apps bietet der Google Play Store eine große Angriffsfläche. Deshalb ist es notwendig, den Fluss sensitiver Daten nachvollziehen zu können. Dies ist mithilfe einer Taint Analyse möglich.
Der Autor möchte im folgenden zunächst auf die Grundlagen der Taint Analyse eingehen und danach die Probleme vorstellen, die bei einer Taint Analyse für Android Apps auftreten. Im Anschluß wird FlowDroid vorgestellt eine Taint Analyse für Android Apps.

\begin{figure}
\lstinputlisting[language=Java]{code/sql_example.java}
\caption{Beispiel bei dem SQL Injections möglich sind}
\label{fig:sql_code}
\end{figure}

\section{Taint Analyse}
\subsection{statisch vs. dynamisch}
Bei der Tain Analyse unterscheidet man zwischen statischer und dynamischer Taint Analyse. Der Vorteil der statischen Variante ist, dass das Kompilat nicht ausgeführt werden muss. Dies ist Hilfreich, da heutige Malware erkennen kann ob sie überwacht wird und kann ihr Verhalten anpassen. Im folgenden wird sich auf die statische Taint Analyse beschränkt.
\subsection{Spezifikation und Vorgehen}
Die Idee der Taint Analyse ist, dass jede von außen veränderbare Variable ein Sicherheitsrisiko birgt. Ihr Ziel ist es die Software gegen externe Angriffe sowie interne Risiken abzusichern. Dazu sucht die Taint Analyse nach Datenflüssen von möglichen tainted sources zu einem sink. Als source wird eine Funktion bezeichnet, die Quelle sensitiver Daten ist. Ein sink ist eine Funktion, die Daten möglicherweiese an nicht vertrauenswürdige Beobachter weitergibt. Welche Funktionen im einzelnen sources und sinks sind, muss vor der Taint Analyse angegeben werden.
\subsection{Formal}
Im Folgendem wird eine Formalisierung der Taint Analyse vorgestellt mithilfe von Schlussregeln 
(\ref{fig:schlussregeln}). Die SOURCE Regel beschreibt die Einfuhr von tainted Daten durch einen source. \emph{src(m,l)} bedeutet, dass dem Parameter \emph{m} Daten aus einer source zugewiesen werden mit dem Namen \emph{l}. \emph{l} stammt aus einem Source-Label-Set. Wenn nun auch \emph{m} auf einen Objektrepräsentanten \emph{o} zeigt, ist \emph{o} durch die Source \emph{l} tainted. Als Objektrepräsentant wird ein Objekt im Sinne der Analyse bezeichnet. Da nicht sicher ist auf wieviele Objekte tatsächlich zur Laufzeit ein Pointer zeigt, fasst man diese Menge zusammen und wählt einen Objekträpresentanten. 
Die zweite Regel TRANSFER beschreibt die Übertragung von tainted Daten. \emph{transfer(m,n)} bedeutet, dass Daten vom Parameter \emph{m} zu \emph{n} übertragen werden. Wenn außerdem der Objektrepräsentant \emph{o1} von einer Source \emph{l} tainted ist und \emph{m} auf \emph{o1} und \emph{n} auf ein \emph{o2} zeigt, dann ist auch \emph{o2} durch \emph{l} tainted.
Die letzte Regel SOURCE beschreibt den Datenfluss von verschmutzen Daten zu einem Sink. Wenn der  Objektrepräsentant \emph{o} durch eine Source \emph{so} tainted ist und die Variable \emph{m}, die auf \emph{o} zeigt einem Sink mit dem Namen \emph{si} übergeben wird, dann gibt es einen Datenfluss von der Source \emph{so} zum Sink \emph{si}. \emph{si} stammt aus einem Sink-Label-Set. 
Mit diesen drei Regeln kann man eine Taint Analyse durchführen indem man diese Fixpunkt Iterativ ausführt, bis nichts mehr gefunden wird.
\begin{figure}
\begin{mathpar}
\infer[(SOURCE)] {tainted(o, l)}{src(m,l)\\ m \rightarrow o}\\\\
\infer[(TRANSFER)] {tainted(o_2, l)}{tainted(o_1,l)\\ m \rightarrow o_1 \\ n \rightarrow o_2 \\ transfer(m,n)}\\\\
\infer[(SOURCE)] {flow(so, si)}{tainted(o,so)\\ m \rightarrow o \\ sink(m,si)} 
\end{mathpar}
\caption{Schlussregeln für die Taint Analyse}
\label{fig:schlussregeln}
\end{figure}

\subsubsection{Beispiel}
Wendet man diese Regeln an dem Beispiel aus Abbildung \ref{fig:sql_code} an, bekommet man folgendes Ergebnis. Zunächst müssen die Sinks und Sources definiert werden. Dazu wird die Funktion \emph{readLine} aus Zeile 4 in das Source-Label-Set eingefügt. In das Sink-Label-Set wird die Funktion \emph{executeQuery} eingefügt. Die Taint Analyse wird zunächst die SOURCE Regel in Zeile 4 anwenden, da dort Daten aus einer Source dem String \emph{name} zugewiesen werden. Somit wird der String \emph{name} als tainted markiert. Als nächstes wird die TRANSFER Regel in Zeile 5 angewendet. Hier werden Daten vom String "name" zum String \emph{sql} übertragen. Deshalb wird auch hier der String \emph{sql} als tainted markiert. In Zeile 5 wird die SINK Regel angewendet. Hier wird der String \emph{sql} in den Sink \emph{executeQuery} übergeben. Da \emph{sql} tainted ist, wird der Sink \emph{executeQuery} auch als tainted markiert. Somit wurde ein tainted Datenfluss von der Source \emph{readLine} zum Sink \emph{executeQuery} gefunden.

\subsection{Sanitization}
Nachdem die Taint Analyse Datenflüsse von sources zu sinks entdeckt hat, sollte dem Programmierer die Möglichkeit gegeben werden, seine eingehenden Daten zu überprüfen und zu säubern. In dem Beispiel aus Abbildung \ref{fig:sql_code} Einige Programmiersprachen bieten solche Säuberungsfunktionen an. PHP hat zum Beispiel die Funktion \emph{htmlentities}, die Zeichen, die in HTML besondere Bedeutung haben in ihre HTML Instanzen konvertiert. Aus dem Zeichen ... wird ... .
% Normaler LNCS Zitierstil
%\bibliographystyle{splncs}
\bibliographystyle{itmalpha}
\bibliography{literatur}

\end{document}
